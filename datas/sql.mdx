---
title: "SQL (Structured Query Language)"
version: ""
versionLink: "https://developer.mozilla.org/en-US/docs/Web/JavaScript"
category: "Language"
language: ""
used: []
author: "Adi Fatkhurozi"
authorLink: "https://github.com/adyfk"
description: "(Structured Query Language) is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS)"
updateAt: "1/2/2022 20:09:00"
createdAt: "1/1/2022 00:00:00"
progress: true
---             


## Basic

Download:  <link to='/sql/sql_demo.zip'> Dummy Database </link> 

### Database Target
```sql
  USE `database_name`;
```

### Data Type
<desc>
  The data type of a col defines what value the col can hold: integer, character, money, date and time, binary, and so on.
</desc>

* <link to='https://www.w3schools.com/sql/sql_datatypes.asp'> Data Type W3School</link>
* <link to='https://www.w3schools.com/sql/sql_dates.asp'> Date Types </link>

### Auto Increment
<note>
  MySQL
</note>

```sql
  CREATE TABLE Persons (
    `col1` INT NOT NULL AUTO_INCREMENT
  );
  -- AUTO_INCREMENT start with value
  ALTER TABLE `table1` AUTO_INCREMENT=100;
```
<note>
  SQL Server
</note>

```sql
  -- IDENTITY(start, incrementBy)
  CREATE TABLE Persons (
    `col1` INT IDENTITY(1,1) PRIMARY KEY
  );
```

## SQL Constraints
SQL constraints are used to specify rules for the data in a table.

### Syntax
```sql
  CREATE TABLE `table1` (
      `col1` datatype constraint,
      `col2` datatype constraint,
      `col3` datatype constraint,
      ....
  );
```

### NOT NULL
<desc>
  Ensures that a col cannot have a NULL value
</desc>
<note>
  By default, a col can hold NULL values.
</note>

```sql  
  `col1` INT NOT NULL
```
### UNIQUE
<desc>
  Ensures that all values in a col are different
</desc>
<note>
  SQL Server / Oracle / MS Access:
</note>

```sql
  `col1` INT NOT NULL UNIQUE
```
<note>
  MySQL:
</note>

```sql
  `col1` INT NOT NULL,
  UNIQUE (`col1`)
```
<note>
  MySQL / SQL Server / Oracle / MS Access:
</note>

```sql 
  --  UNIQUE constraint on multiple cols
  `col1` INT NOT NULL,
  `col2` VARCHAR(255) NOT NULL,
  CONSTRAINT `UC_Table` UNIQUE (`col1`,`col2`)
```


### PRIMARY KEY
<desc>
  A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
</desc>
<note>
  SQL Server / Oracle / MS Access:
</note>

```sql
  `col1` INT NOT NULL PRIMARY KEY,
```
<note>
  MySQL:
</note>

```sql
  `col1` INT NOT NULL,
  PRIMARY KEY (`col1`)
```
<note>
  MySQL / SQL Server / Oracle / MS Access:
</note>

```sql 
  -- PRIMARY KEY constraint on multiple cols
  `col1` INT NOT NULL,
  `col2` VARCHAR(255) NOT NULL,
  CONSTRAINT `PK_Table` PRIMARY KEY (`col1`,`col2`)
```

### FOREIGN KEY
<desc>
  Prevents actions that would destroy links between tables
</desc>
<note>
  SQL Server / Oracle / MS Access:
</note>

```sql
  `col1` INT FOREIGN KEY REFERENCES `table_target`(`col_target`)
```
<note>
  MySQL:
</note>

```sql
  `col1` INT,
  FOREIGN KEY (`col1`) REFERENCES `table_target`(`col_target`)
```
<note>
  MySQL / SQL Server / Oracle / MS Access:
</note>

```sql 
  -- FOREIGN KEY constraint on multiple cols
  `col1` INT, 
  CONSTRAINT `FK_Table` FOREIGN KEY (`col1`)
  REFERENCES `table_target`(`col_target`)
```

### CHECK
<desc>
  Ensures that the values in a col satisfies a specific condition
</desc>
<note>
  SQL Server / Oracle / MS Access:
</note>

```sql
  `col1` INT CHECK (`col1`>=18)
```
<note>
  MySQL:
</note>

```sql
  `col1` INT,
  `col2` VARCHAR(10),
  CONSTRAINT `CHK_Table` CHECK (`col1`>=18 AND `col2`='Sandnes')  
```
<note>
  MySQL / SQL Server / Oracle / MS Access:
</note>

```sql 
  -- CHECK constraint on multiple cols
  `col1` INT, 
  CONSTRAINT `FK_Table` FOREIGN KEY (`col1`)
  REFERENCES `table_target`(`col_target`)
```

### DEFAULT
<desc>
  Sets a default value for a col if no value is specified
</desc>
<note>
  SQL Server / Oracle / MS Access:
</note>

```sql
  `col1` date DEFAULT GETDATE(),
  `col2` varchar(255) DEFAULT 'Men',
```

### CREATE INDEX
<desc>
  Used to create and retrieve data from the database very quickly
</desc>
<note>
  Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So, only create indexes on columns that will be frequently searched against.
</note>

```sql
  CREATE INDEX `index_name`
  ON `table_target` (`col1`, `col2`, ...);
```


## Manipulating

### Create Database
```sql
  CREATE DATABASE `database_name`; 
```

### Create Table
```sql
  CREATE TABLE `table_name` ();
```

### Delete Table 
```sql
  DROP TABLE `table_name`;
```

### Add Column
```sql
  ALTER TABLE `table_name`
  ADD `column_name` datatype;
```

### Modify Column
```sql
  ALTER TABLE `table_name`
  ALTER COLUMN `column_name` datatype;
```

### Delete Column
```sql
  ALTER TABLE `table_name`
  DROP COLUMN `column_name`;
```

### Copy of Table
```sql 
  CREATE TABLE `table1` AS SELECT * FROM `table_target`;
```

### Insert 
<desc>
  Specify both the column names and the values to be inserted:
</desc>

```sql
  INSERT INTO `table_name` (column1, ...) VALUES (value1, ...);
  -- for multiple values
  -- VALUES (value1, ...), (value1, ...);
```
<desc>
  If you are adding values for all the columns of the table, you do not need to specify the column names in the SQL query
</desc>

```sql
  INSERT INTO `table_name` VALUES (value1, ...);
```
<desc>
  Insert Hierarchical Rows
</desc>

```sql
  INSERT INTO `table1` VALUES (NULL, 'code');
  -- get id after insert
  INSERT INTO `table2` VALUES (LAST_INSERT_ID(), 'code');
```

### Update
```sql
  UPDATE `table_name`
  SET column1 = value1, column2 = value2, ...
  WHERE condition;
```

### Delete
```sql
  DELETE FROM `table_name` WHERE condition;
```





## Select

### All
```sql
  SELECT * FROM `table1`;
```

### Some
```sql
  SELECT `col1`, `col2` FROM `table1`;
```

### Alias
```sql
  SELECT `col1` AS `name` FROM `table1`;
  SELECT `o`.`col1`, `p`.`col2` FROM `table1` AS `o`, `table2` AS `p` ;

  -- in mysql make it shorter
  SELECT `o`.`col1`, `p`.`col2` FROM `table1` `o`, `table2` `p` ;
```

### Static
```sql
  -- will add column status with value Active in every row
  SELECT *, "Active" AS `status`
  FROM `table1`
  WHERE `date` >= '2021';
```

### Distinct
<desc>
  statement is used to return only distinct (different) values.
</desc>

```sql
  SELECT DISTINCT `col1`, `col2` FROM `table1`;
```

### Min, Max, Count, Avg, & Sum
```sql
   SELECT MIN(`col1`) FROM `table1`;
   SELECT MAX(`col1`) FROM `table1`;
   SELECT COUNT(`col1`) FROM `table1`;
   SELECT AVG(`col1`) FROM `table1`;
   SELECT SUM(`col1`) FROM `table1`;
```


### Where

```sql
  --  SELECT column1, column2 FROM table1 WHERE condition;
  WHERE `col1` = 1;
  WHERE `col1` = '1';
  WHERE `col1` <> 2;
  WHERE `col1` IN (val1,val2);
  WHERE `col1` BETWEEN 50 AND 60;
  WHERE `col1` REGEXP '[abc]'
  -- _ = single character
  -- % = any number of characters
  -- more wildcards like regex in reference
  WHERE `col1` LIKE '_s';
  WHERE `col1` LIKE 's%';
  -- OR, AND, NOT
  WHERE `col1` = '1' OR `col2` = '2';
  -- IS NULL
  WHERE `col1` IS NULL;
```
<note>
  Reference: <link to='https://www.w3schools.com/sql/sql_wildcards.asp'>LIKE (Wildcard)</link>
</note>

### Order By
```sql
  SELECT * FROM `table1`
  ORDER BY `col1` DESC;

  SELECT * FROM `table1`
  ORDER BY `col1` ASC;
```

### Limit
```sql
  -- get 3 rows
  SELECT * FROM `table1` LIMIT 3

  -- pagination case (offset, page)
  -- get 3 rows in page 2
  SELECT * FROM `table1` LIMIT 3, 2
```

### Union 
<desc>
  The UNION operator is used to combine the result-set of two or more SELECT statements.
</desc>

* Must have the same number of columns
* Must also have similar data types
* Must also be in the same order

```sql
  --  (only distinct values) from both the table
  SELECT `col1` FROM `table1`
  UNION
  SELECT `col1`  FROM `table2`;

  -- also select duplicate values
  SELECT `col1` FROM `table1`
  UNION ALL
  SELECT `col1`  FROM `table2`;
```

### Group By
<desc>
  groups rows that have the same values into summary rows, like "find the number of customers in each country".
</desc>

```sql
  SELECT COUNT(CustomerID), Country
  FROM Customers
  GROUP BY Country
  ORDER BY COUNT(CustomerID) DESC;
```

### Having
<desc>
  because the WHERE keyword cannot be used with aggregate functions
</desc>

```sql
  SELECT COUNT(CustomerID), Country
  FROM Customers
  GROUP BY Country
  HAVING COUNT(CustomerID) > 5
  ORDER BY COUNT(CustomerID) DESC;
```
###
### Exists
* used to test for the existence of any record in a subquery.
* returns TRUE if the subquery returns one or more records.

```sql
  SELECT SupplierName
  FROM Suppliers
  WHERE EXISTS (
    SELECT ProductName 
    FROM Products 
    WHERE Products.SupplierID = Suppliers.supplierID 
    AND Price < 20
  );
```

### Any, All
<desc>
  The ANY and ALL operators allow you to perform a comparison between a single column value and a range of other values. <br/>
  <text>ANY</text> One Of List <br/>
  <text>ALL</text> All Of List <br/>
</desc>

```sql
  -- WHERE qty > ANY (20, 559, 902)
  -- WHERE qty > ALL (20, 559, 902)

  SELECT ProductName
  FROM Products
  WHERE ProductID = ANY (
    SELECT ProductID
    FROM OrderDetails
    WHERE Quantity = 10
  );
```

### Into
<desc>
  Statement copies data from one table into a new table.
</desc>

```sql
  -- SELECT * INTO newtable [IN externaldb]
  -- FROM oldtable WHERE condition;
  SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
  FROM Customers;

  SELECT CustomerName, ContactName INTO CustomersBackup2017
  FROM Customers;
```

### Case
<desc>
  statement goes through conditions and returns a value when the first condition is met (like an if-then-else statement)
</desc>

```sql
  SELECT OrderID, Quantity,
  CASE
      WHEN Quantity > 30 THEN 'The quantity is greater than 30'
      WHEN Quantity = 30 THEN 'The quantity is 30'
      ELSE 'The quantity is under 30'
  END AS QuantityText
  FROM OrderDetails;
```
<note><b>IF</b></note>

```sql
  SELECT 
    order_id, 
    order_date, 
    IF(
      YEAR(order_date) = YEAR(NOW()), 
      'Active', 
      'Archive'
    ) AS CATEGORY
  FROM Orders
```

### Rollup 
<desc>Rollup operator calculates the summary for each group.</desc>
<danger>Its only available on in MySQL, its not part of standart SQL language</danger>

```sql
  SELECT 
    city,
    SUM(invoice_total) AS total_sales
  FROM invoices i
  GROUP BY city WITH ROLLUP
```

### Null Functions
```sql
  --- IFNULL(), ISNULL(), COALESCE(), and NVL()
  SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
  FROM Products;
```

## Join Table

<img alt='sql-join' width='32%' src='/sql/sql-join.jpg' />
<note>
</note>

### Inner Join
<desc>
  keyword selects records that have matching values in both tables.
</desc>

```sql
  SELECT *
  FROM `table1`
  INNER JOIN `table2`
  ON `table1`.`col1` = `table2`.`col1`;
```
<note>
  Shorter USING syntax if identical column
</note>

```sql
  SELECT *
  FROM `table1`
  INNER JOIN `table2`
    USING ('col1')
```

### Natural Join
<desc>
  Will look at these two tables and it will join them based on the common columns.
  The columns that have the same name.
</desc>
<danger>
  Really easy to code, but they can be a little dangerous because we are letting
  the database engine, figure out or guess the join.
</danger>

```sql
  SELECT * 
  FROM orders o
  NATURAL JOIN customers c;
```

### Left Join
<desc>
  keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match.
</desc>

```sql
  SELECT *
  FROM `table1`
  LEFT JOIN `table2`
  ON `table1`.`col1` = `table2`.`col1`;
```

### Right Join
<desc>
  keyword returns all records from the right table (table2), and the matching records from the left table (table1). The result is 0 records from the left side, if there is no match.
</desc>

```sql
  SELECT *
  FROM `table1`
  RIGHT JOIN `table2`
  ON `table1`.`col1` = `table2`.`col1`;
```

### Full Join
<desc>
  keyword returns all records when there is a match in left (table1) or right (table2) table records.
</desc>
<note>
  FULL OUTER JOIN and FULL JOIN are the same.
</note>

```sql
  SELECT *
  FROM `table1`
  FULL OUTER JOIN `table2`
  ON `table1`.`col1` = `table2`.`col1`;
```

### Self Join 
```sql 
  SELECT e.employee_id, e.first_name, m.first_name AS 'Manager'
  FROM employees e
  JOIN employees m
    ON e.reports_to = m.employee_id
```

### Subqueries
```sql
  SELECT * FROM employees
  WHERE salary > (
    SELECT AVG(salary) FROM employees
  );
```
<note>Correlated Subqueries</note>
<danger>
  when we use correlated subquery, this subquery gets executed for each row. 
  The more data you have the more overhead your query is going
</danger>

```sql
  SELECT * FROM employees e
  WHERE clients > (
    SELECT AVG(salary) FROM employees 
    WHERE office_id = e.office_id
  )
```

## MySQL Functions

### Numeric
```sql
  SELECT ROUND(5.76, 1); -- 5.8
  SELECT TRUNCATE(5.59, 1); -- 5.5
  SELECT CEILING(5.2); -- 6
  SELECT FLOOR(5.9); -- 5
  SELECT ABS(-5); -- 5
  SELECT RAND(); -- random 0.000 - 1.000
```
<note>
  Reference:
  <link to='https://dev.mysql.com/doc/refman/8.0/en/numeric-functions.html'>
    Numeric Functions
  </link>
</note>

### String
```sql
  SELECT LENGTH('sky'); -- 3
  SELECT UPPER('Sky'); -- 'SKY'
  SELECT LOWER('Sky'); -- 'sky'
  SELECT TRIM('  Sky '); -- 'Sky' (LTRIM, RTRIM)
  SELECT LEFT('abcdefg',3); -- 'abc' (RIGHT, SUBSTRING)
  SELECT LOCATE('n','abcdefg') -- 3 (not case sensitive)
  SELECT REPLACE('abcdefg','a','b') -- 'bbcdefg' (not case sensitive)
  SELECT CONCAT('a',' ','a') -- 'a a'
```
<note>
  Reference:
  <link to='https://dev.mysql.com/doc/refman/8.0/en/string-functions.html'>
    String Functions
  </link>
</note>

### Date
```sql
  SELECT 
    NOW(),                    -- '2022-02-01 23:28:55'
    CURDATE(),                -- '2022-02-01'
    CURTIME(),                -- '23:28:55'
    MONTH(NOW()),             -- 2
    MONTHNAME(NOW())          -- `March`
    EXTRACT(YEAR FROM NOW()); -- 2022 
    DATE_FORMAT(NOW(), '%d %D %m %M %Y')  -- 1 Monday 3 March 2019
```
<note>
  Reference:
  <link to='https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html'>
    Date Functions
  </link>
</note>

### Calculate Date
```sql
  SELECT 
    DATE_ADD(NOW(), INTERVAL 1 DAY), -- tomorrow
    DATE_SUB(NOW(), INTERVAL 1 YEAR), -- last year
    DATEDIFF('2019-01-05', '2019-01-01'), -- 4
    TIME_TO_SEC('09:00');
```
<note>
  Reference:
  <link to='https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html'>
    Date Functions
  </link>
</note>

## View
  We can save these queries or subqueries in a view, and this will greatly simplify
  our select statements, and then we can reuse these views so we don't have to code those queries again.\
  So a view behaves like a virtual table, but remember, view don't tore data, our data is actually stored in our tables

<note>
  INSERT, UPDATE, DELETE only under certain circumstances. If the view does'nt have <br/>
  1. DISTINCT <br/>
  2. Aggregate Functions (MIN, MAX, SUM, COUNT, etc) <br/>
  3. GROUP BY / HAVING <br/>
  4. UNION
</note>

### Create
```sql
  CREATE VIEW sales_by_client AS
  SELECT 
    c.client_id,
    c.name,
    SUM(invoice_total) AS total_sales
  FROM clients calculates
  JOIN invoices i USING (client_id)
  GROUP BY client_id, name;

  -- now u can see like table 
  SELECT * FROM sales_by_client;
```

### Altering Or Droping
```sql
  -- Altering
  CREATE OR REPLACE VIEW sales_by_client AS
  SELECT 
      c.client_id,
      c.name,
      SUM(invoice_total) AS total_sales
    FROM clients calculates
    JOIN invoices i USING (client_id)
    GROUP BY client_id, name;
  -- Drop
  DROP VIEW sales_by_client;
```

### Updateable View
```sql
  CREATE VIEW invoices_with_balance AS
  SELECT 
    invoice_id, 
    client_id, 
    invoice_total, 
    payment_total, 
    invoice_total - payment_total AS balance,
    invoice_date,
    due_date,
    payment_date
  FROM invoices
  WHERE (invoice_total - payment_total) > 0;
  -- DELETE
  DELETE FROM invoices_with_balance WHERE invoice_id = 1;
  -- UPDATE
  UPDATE invoices_with_balance
  SET due_date = DATE_ADD(due_date, INTERVAL 2 DAY)
  WHERE invoice_id = 2;

  -- IF You don't want an update or delete statement to exclude a row
  WITH CHECK OPTION
```

## Stored Procedures

* **Store and Organize SQL**
* **Faster execution**
* **Data security**  

### Create
```sql
  -- DELIMITER = to change semicolon `;` to something else
  -- DELIMITER [any]
  DELIMITER $$
  CREATE PROCEDURE `get_clients`()
  BEGIN
    SELECT * FROM clients;
  END$$
  -- with $$ will take statement to one unit 

  -- back to semicolon
  DELIMITER ;

  -- how to call function
  CALL get_clients();
```
### Parameters
```sql
  DELIMITER $$
  CREATE PROCEDURE `get_clients_by_state`(
    state CHAR(2)
  )
  BEGIN
    IF(state IS NULL) THEN 
     SELECT * FROM clients c
    ELSE
     SELECT * FROM clients c
     WHERE c.state = state;
    END IF;
  END $$

  DELIMITER ;

  CALL get_clients_by_state('CA');
```

### Parameter Default 
```sql
  DELIMITER $$
  CREATE PROCEDURE `get_clients_by_state`(
    state CHAR(2)
  )
  BEGIN
    -- Add default parameter case 1
    IF(state IS NULL) THEN 
      SET state = 'CA'
    END IF;

    SELECT * FROM clients c
    WHERE c.state = state;

    -- Add default parameter case 2
    -- SELECT * FROM clients c
    -- WHERE c.state = IFNULL(state, 'CA');
  END $$

  DELIMITER ;

  CALL get_clients_by_state('CA');
```

### Paramter validation
```sql
  DELIMITER $$
  CREATE PROCEDURE `get_clients_by_state`(
    state CHAR(2)
  )
  BEGIN
    IF(state IS NULL) THEN
       SIGNAL SQLSTATE '22004'
       SET MESSAGE_TEXT = 'Invalid state null'
    END IF;
    SELECT * FROM clients;
  END $$
  DELIMITER ;

  CALL get_clients_by_state(NULL);
```
<desc>
  Reference : 
  <link to='https://www.ibm.com/docs/en/db2-for-zos/11?topic=codes-sqlstate-values-common-error'>
    SQLState Errors Codes
  </link>
</desc>

### Output Parameter
```sql
  DELIMITER $$
  CREATE PROCEDURE `get_unpaid_invoices_for_client`
  (
    client_id INT,
    OUT invoices_count TINYINT,
    OUT invoices_total DECIMAL(9,2)
  )
  BEGIN
    SELECT COUNT(*), SUM(invoice_total)
    INTO invoices_count, invoices_total
    FROM invoices i
    WHERE i.client_id = client_id 
      AND payment_total = 0;
  END$$
  DELIMITER ;

  -- Implement
  SET @invoice_count = 0;
  SET @invoice_total = 0;
  CALL get_unpaid_invoices_for_client
    (1,  @invoice_count, @invoice_total);
  SELECT @invoice_count, @invoice_total;
```

### Variable
```sql
  -- User or session Variables
  SET @invoices_count = 0;

  -- Local Variable
  DELIMITER $$
  CREATE PROCEDURE `get_risk_factor`()
  BEGIN
    DECLARE risk_factor DECIMAL(9,2) DEFAULT 0;
    DECLARE invoics_count DECIMAL(9,0);
    DECLARE invoics_count INT;

    SELECT COUNT(*), SUM(invoice_total)
    INTO invoics_count, invoics_count
    FROM invoices;

    SET risk_factor = invoice_total / invoics_count * 5;
    SELECT risk_factor;
  END$$
  DELIMITER ;

  CALL get_risk_factor()
```

### Drop
```sql
  DROP PROCEDURE `get_clients`
  -- DROP PROCEDURE IF EXISTS `get_clients`
```

## Functions
Create own function like MIN, MAX, COUNT, et \
this only can result single value

### Create
```sql
  CREATE FUNCTION `get_risk_factor_for_client`
  (
    client_id INT
  )
  RETURNS INTEGER
  -- // DETERMINISTIC, if we give this function the same set of values,
  -- // it always returns the same value. This is useful in situations where
  -- // ex : when params 2 will return 'Genap '
  -- DETERMINISTIC

  READS SQL DATA
  -- // MODIFIES SQL DATA
  BEGIN
    DECLARE risk_factor DECIMAL(9,2) DEFAULT 0;
    DECLARE invoics_count DECIMAL(9,0);
    DECLARE invoics_count INT;

    SELECT COUNT(*), SUM(invoice_total)
    INTO invoics_count, invoics_count
    FROM invoices i 
    WHERE i.client_id = client_id;

    SET risk_factor = invoice_total / invoics_count * 5;
    RETURN risk_factor;
  END

  -- Implement
  SELECT 
    client_id,
    get_risk_factor_for_client(client_id) AS risk_factor
  FROM clients; 
```

### Drop
```sql
  DROP FUNCTION IF EXISTS `get_risk_factor_for_client`;
```

## Tiggers & Events
<desc>
  [AFTER|BEFORE] [INSERT|UPDATE|DELETE] ON
</desc>

### Create
```sql
  DELIMITER $$
  -- sometime format (table-[before|after]-event)
  -- NEW, OLD (to get table attribut)
  -- EVENT delete only can use (OLD)
  CREATE TRIGGER payments_after_insert
    AFTER INSERT ON payments
    FOR EACH ROW
  BEGIN
    UPDATE invoices
    SET payment_total = payment_total + NEW.amount
    WHERE invoice_id = NEW.invoice_id;
  END $$
  DELIMITER ;
```

### Show
```sql
  -- SHOW TRIGGERS;
  -- SHOW EVENTS;
  -- SHOW TRIGGERS LIKE 'payments%';
```

### Drop
```sql
  DROP TRIGGER `payments_after_insert`;
  -- DROP TRIGGER IF EXISTS `payments_after_insert`;
```

###
### Events
```sql
  -- // check if event scheluler ON
  -- SHOW VARIABLES LIKE 'event%';
  -- SET GLOBAL event_scheduler = OFF|ON;

  DELIMITER $$
  CREATE EVENT yearly_delete_stale_audit_rows
  ON SCHEDULE
    -- AT `2019-05-1`  (on time excution)
    EVERY 1 YEAR START '2019-01-01' ENDS '2029-01-01'
  
  DO BEGIN
      DELETE FROM payments_audit
      WHERE action_date < NOW() - INTERVAL 1 YEAR; 
      -- DATEADD(NOW. INTERVAL 1 YEAR) // longtype

  END$$
```

### Alter Events
```sql
  ALTER EVENT yearly_delete_stale_audit_rows
  ON SCHEDULE
  ...
  END
```