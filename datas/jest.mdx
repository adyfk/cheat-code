---
title: "Jest"
version: "24.4"
versionLink: "https://jestjs.io/"
category: "Testing"
language: "Javascript"
used: []
author: "Adi Fatkhurozi"
authorLink: "https://github.com/adyfk"
description: "Jest is a delightful JavaScript Testing Framework with a focus on simplicity. It works with projects using: Babel, TypeScript, Node, React, Angular, Vue and more!"
updateAt: "21/1/2022 23:30:00"
---             

## Getting Started

### Install & Init
```bash
  yarn add --dev jest 
  // or
  npm install --save-dev jest
  // or using Babel
  yarn add -D babel-jest @babel/core @babel/preset-env  

  // init configuration
  jest --init
```
<note>
  reference: <link to='https://jestjs.io/docs/getting-started'>Getting Started</link>
</note>

### Install Jest-Dom
```bash
  npm install --save-dev @testing-library/jest-dom
  // or
  yarn add --dev @testing-library/jest-dom
```

### Babel Config
```js
  // babel.config.js
  module.exports = {
    presets: [
      [
        '@babel/preset-env',
        {targets: {node: 'current'}}   
      ],
      '@babel/preset-typescript' // Optional   
    ],
  };
```

### Setup and Teardown
```js
  beforeAll(() => console.log('1 - beforeAll'));
  afterAll(() => console.log('1 - afterAll'));
  beforeEach(() => console.log('1 - beforeEach'));
  afterEach(() => console.log('1 - afterEach'));
  test('test-case', () => console.log('1 - test'));
  describe('Scoped / Nested block', () => {
    beforeAll(() => console.log('2 - beforeAll'));
    afterAll(() => console.log('2 - afterAll'));
    beforeEach(() => console.log('2 - beforeEach'));
    afterEach(() => console.log('2 - afterEach'));
    test('test-case', () => console.log('2 - test'));
  });
  // 1 - beforeAll, 1 - beforeEach, 1 - test, 1 - afterEach, 2 - beforeAll, 1 - beforeEach, 2 - beforeEach, 2 - test, 2 - afterEach, 1 - afterEach, 2 - afterAll, 1 - afterAll
```

## Using Matchers (expect)
to make writing short, the "`expect`" function will use the alias "`ec`"

### Truthiness
```js
  ec(null).toBeNull();
  ec(undefined).toBeDefined();
  // matches anything that an if statement  
  ec(true).toBeTruthy();
  ec(false).toBeFalsy();  
  // not undefined
  ec(true).toBeDefined()
  ec(NAN).toBeNaN()
```

### Numbers
```js
  ec(4).toBeGreaterThan(3);
  ec(4).toBeGreaterThanOrEqual(3.5);
  ec(4).toBeLessThan(5);
  ec(4).toBeLessThanOrEqual(4.5);

  // toBe using (===) 
  ec(4).toBe(4);
  ec(4).toEqual(4);

  // This won't work because of rounding error
  ec(0.1 + 0.2).toBe(0.3);       
  // toBeCloseTo(number, numDigits?) This works.
  ec(0.1 + 0.2).toBeCloseTo(0.3); 
```

### String
```js
  // toBe using (===)
  ec('cheat').toBe('cheat');
  ec('cheat').toEqual('cheat');

  // regex
  ec('1').toMatch('1')
  ec('1').toMatch(/1/)

  ec('cheat').toHaveLength(5)
```

### Array
```js
  ec(['cheat']).toContain('cheat');
  ec([4,3,2]).toHaveLength(3)
  ec([{name:'cheat'}]).toContainEqual({name:'cheat'})
  ec([{name:'cheat'}]).toMatchObject({name:'cheat'})
```

### Object
```js
  // toEqual to compare recursively all properties of 
  // object instances (also known as "deep" equality)
  const a = { name: 'cheat', birth: { date: 1 } };
  const b = { name: 'cheat', birth: { date: 1 } }

  ec(a).toEqual(b)

  // toHaveProperty(keyPath, value?)
  ec(a).toHaveProperty('name')
  ec(a).toHaveProperty('name', 'cheat')
  
  // match object
  ec(a).toMatchObject({ birth: { date: 1 } })
```

### Function
```js
  const drink = jest.fn((param)=>param);
  drink('cheat', 'code');
  ec(drink).toHaveBeenCalled();
  ec(drink).toHaveBeenCalledTimes(1)
  ec(drink).toHaveBeenCalledWith('cheat', 'code')
  drink('code')
  ec(drink).toHaveBeenLastCalledWith('code')
  ec(drink).toHaveBeenNthCalledWith(1, 'cheat', 'code')
  ec(drink).toHaveBeenNthCalledWith(2, 'code')

  // to test that the mock function successfully returned
  // (i.e., did not throw an error) at least one time
  ec(drink).toHaveReturned()
  ec(drink).toHaveReturnedTimes(2);
  ec(drink).toHaveReturnedWith('code')
```
<note>
  see: <link to='https://jestjs.io/docs/expect#tohavereturnedwithvalue'>Return</link>
</note>

### Exceptions
```js
  function fn() {
      throw new Error('you are using the wrong JDK');
  }

  ec(fn).toThrow();
  ec(fn).toThrow(Error);
  
  // string / regexp
  ec(fn).toThrow('you are using the wrong JDK');
  ec(fn).toThrow(/JDK/);

  ec(Promise.reject(new Error('octopus')))
    .rejects.toThrow('octopus',);
```

### Promise 
```js
  test('resolves to lemon', async () => {
    await expect(Promise.resolve('lemon')).resolves.toBe('lemon');
    await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');
  });
  test('rejects to octopus', () => {
    // make sure to add a return statement
    return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(
      'octopus',
    );
  });
```

### Negation
```js
  ec(true).not.toBeNull();
```

## Mock
Mock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output

### Mock Name
```js
  const mockFn = jest.fn().mockName('mockedFunction');
  ec(mockFn).toHaveBeenCalled();
  // result
  // Expected mock function "mockedFunction" to have been called, but it was not called.
```

### Mock Implementation
```js
  const fn = jest.fn().mockImplementation(()=>{})
  // shorthand
  const fn = jest.fn(()=>{})

  const myMockFn = jest
    .fn()
    .mockImplementationOnce(cb => cb(null, true))
    .mockImplementationOnce(cb => cb(null, false));
  myMockFn((err, val) => console.log(val)); // true
  myMockFn((err, val) => console.log(val)); // false

  const myMockFn = jest
    .fn(() => 'default')
    .mockImplementationOnce(() => 'first call')
    .mockImplementationOnce(() => 'second call');
  // 'first call', 'second call', 'default', 'default'
  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### Get History Args
```js
  const callTimesIndex = 0;
  const callArgsIndex = 0
  mockFn.mock.calls[callTimes][callArgs]
  // ex: 
  const fn = jest.fn(()=>{}) 
  fn(1)
  fn.mock.calls[0][0] === 1
```

### Mock Return
```js
  const myMockFn = jest.fn()
    .mockReturnValue('default')
    .mockReturnValueOnce('first call')
    .mockReturnValueOnce('second call');
  // 'first call', 'second call', 'default', 'default'
  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### Mock Rejected & Resolved
<note>Resolved</note>

```js
    const asyncMock = jest
      .fn()
      .mockResolvedValue('default')
      .mockResolvedValueOnce('first call')
      .mockResolvedValueOnce('second call');

    await asyncMock(); // first call
    await asyncMock(); // second call
    await asyncMock(); // default
    await asyncMock(); // default
```
<note>Rejected</note>

```js
  const asyncMock = jest
    .fn()
    .mockRejectedValue(new Error('Async error 1'))
    .mockRejectedValueOnce(new Error('Async error'));

  await asyncMock(); // throws "Async error 1"
  await asyncMock(); // throws "Async error"
```

### Mock Module
<note>SomeClass.js</note>

```js
  module.exports = class SomeClass {
    m(a, b) {}
  };
```
<note>test.js</note>

```js
  jest.mock('./SomeClass'); // this happens automatically with automocking
  const SomeClass = require('./SomeClass');
  const mMock = jest.fn();
  
  SomeClass.mockImplementation(() => ({ m: mMock }));
  const some = new SomeClass();
  some.m('a', 'b');
  console.log('Calls to m: ', mMock.mock.calls);
```

### Typescript Mocked Module
<note>
jest.MockedFunction is available in the @types/jest module from version 24.9.0
<br/>---------------------------------<br/>
You can use jest.MockedFunction to represent a function that has been replaced by a Jest mock.
</note>

```typescript
  // Assume `add` is imported and used within `calculate`.
  import add from './add';
  import calculate from './calc';
  jest.mock('./add');
  // Our mock of `add` is now fully typed
  const mockAdd = add as jest.MockedFunction<typeof add>;
  calculate('Add', 1, 2);
  expect(mockAdd).toBeCalledTimes(1);
  expect(mockAdd).toBeCalledWith(1, 2);

  // or using jest.fn
  const mockAdd = jest.fn() as jest.MockedFunction<typeof add>;
  mockAdd.mockImplementation((a, b) => a + b);
  calculate(mockAdd, 1, 2);
  expect(mockAdd).toBeCalledTimes(1);
  expect(mockAdd).toBeCalledWith(1, 2);
```

###

### Typescript Mock Class Module
<note>
  jest.MockedClass is available in the @types/jest module from version 24.9.0
</note>

```typescript
  import SoundPlayer from '../sound-player';
  import SoundPlayerConsumer from '../sound-player-consumer';
  jest.mock('../sound-player'); // SoundPlayer is now a mock constructor

  const SoundPlayerMock = SoundPlayer as jest.MockedClass<typeof SoundPlayer>;

  beforeEach(() => {
    // Clear all instances and calls to constructor and all methods:
    SoundPlayerMock.mockClear();
  });

  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(SoundPlayerMock).toHaveBeenCalledTimes(1);

  const coolSoundFileName = 'song.mp3';
  soundPlayerConsumer.playSomethingCool();

  // mock.instances is available with automatic mocks:
  const mockSoundPlayerInstance = SoundPlayerMock.mock.instances[0];

  // However, it will not allow access to `.mock` in TypeScript as it
  // is returning `SoundPlayer`. Instead, you can check the calls to a
  // method like this fully typed:
  expect(SoundPlayerMock.prototype.playSoundFile.mock.calls[0][0])
    .toEqual(coolSoundFileName);
```


## Jest Object

### Mocking 
```js
  jest.enableAutomock();
  jest.disableAutomock();

  // or you can set to jest config  
  {
    "automock": true
  }
  // or manualy mock
  jest.mock(moduleName, factory, options)
  // ex = jest.mock('../moduleName', () => jest.fn(() => 42));
  jest.unmock(moduleName)
```
<note>
  <strong>doMock</strong> <br/>
  When using babel-jest, calls to mock will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.
</note>


```js
  test('moduleName 1', () => {
    jest.doMock('../moduleName', () => jest.fn(() => 1));
  });
  test('moduleName 1', () => {
    jest.doMock('../moduleName', () => jest.fn(() => 2));
  });
```

### Craete Mock From Module
<note>
  utils.js  
</note>

```js
  export default {
    authorize: () => {
      return 'token';
    },
    isAuthorized: secret => secret === 'wizard',
  };
```
<note>
  test.js  
</note>

```js
  const utils = jest.createMockFromModule('./utils').default;
  utils.isAuthorized = jest.fn(secret => secret === 'not wizard');

  test('implementation created by jest.createMockFromModule', () => {
    expect(utils.authorize.mock).toBeTruthy();
    expect(utils.isAuthorized('not wizard')).toEqual(true);
  });
```