---
title: "Jest"
version: "24.4"
versionLink: "https://jestjs.io/"
category: "Testing"
language: "Javascript"
used: []
author: "Adi Fatkhurozi"
authorLink: "https://github.com/adyfk"
description: "Jest is a delightful JavaScript Testing Framework with a focus on simplicity. It works with projects using: Babel, TypeScript, Node, React, Angular, Vue and more!"
updateAt: "21/1/2022 23:30:00"
---             

## Getting Started

### Install & Init
```bash
  yarn add --dev jest 
  // or
  npm install --save-dev jest
  // or using Babel
  yarn add -D babel-jest @babel/core @babel/preset-env  

  // init configuration
  jest --init
```
<note>
  reference: <link to='https://jestjs.io/docs/getting-started'>Getting Started</link>
</note>

### Babel Config
```js
  // babel.config.js
  module.exports = {
    presets: [
      [
        '@babel/preset-env',
        {targets: {node: 'current'}}   
      ],
      '@babel/preset-typescript' // Optional   
    ],
  };
```

## Using Matchers (expect)
to make writing short, the "`expect`" function will use the alias "`ec`"

### Truthiness
```js
  ec(null).toBeNull();
  ec(undefined).toBeDefined();
  // matches anything that an if statement  
  ec(true).toBeTruthy();
  ec(false).toBeFalsy();  
  // not undefined
  ec(true).toBeDefined()
  ec(NAN).toBeNaN()
```

### Numbers
```js
  ec(4).toBeGreaterThan(3);
  ec(4).toBeGreaterThanOrEqual(3.5);
  ec(4).toBeLessThan(5);
  ec(4).toBeLessThanOrEqual(4.5);

  // toBe using (===) 
  ec(4).toBe(4);
  ec(4).toEqual(4);

  // This won't work because of rounding error
  ec(0.1 + 0.2).toBe(0.3);       
  // toBeCloseTo(number, numDigits?) This works.
  ec(0.1 + 0.2).toBeCloseTo(0.3); 
```

### String
```js
  // toBe using (===)
  ec('cheat').toBe('cheat');
  ec('cheat').toEqual('cheat');

  // regex
  ec('1').toMatch('1')
  ec('1').toMatch(/1/)

  ec('cheat').toHaveLength(5)
```

### Array
```js
  ec(['cheat']).toContain('cheat');
  ec([4,3,2]).toHaveLength(3)
  ec([{name:'cheat'}]).toContainEqual({name:'cheat'})
  ec([{name:'cheat'}]).toMatchObject({name:'cheat'})
```

### Object
```js
  // toEqual to compare recursively all properties of 
  // object instances (also known as "deep" equality)
  const a = { name: 'cheat', birth: { date: 1 } };
  const b = { name: 'cheat', birth: { date: 1 } }

  ec(a).toEqual(b)

  // toHaveProperty(keyPath, value?)
  ec(a).toHaveProperty('name')
  ec(a).toHaveProperty('name', 'cheat')
  
  // match object
  ec(a).toMatchObject({ birth: { date: 1 } })
```

### Function
```js
  const drink = jest.fn((param)=>param);
  drink('cheat', 'code');
  ec(drink).toHaveBeenCalled();
  ec(drink).toHaveBeenCalledTimes(1)
  ec(drink).toHaveBeenCalledWith('cheat', 'code')
  drink('code')
  ec(drink).toHaveBeenLastCalledWith('code')
  ec(drink).toHaveBeenNthCalledWith(1, 'cheat', 'code')
  ec(drink).toHaveBeenNthCalledWith(2, 'code')

  // to test that the mock function successfully returned
  // (i.e., did not throw an error) at least one time
  ec(drink).toHaveReturned()
  ec(drink).toHaveReturnedTimes(2);
  ec(drink).toHaveReturnedWith('code')
```
<note>
  see: <link to='https://jestjs.io/docs/expect#tohavereturnedwithvalue'>Return</link>
</note>

### Exceptions
```js
  function fn() {
      throw new Error('you are using the wrong JDK');
  }

  ec(fn).toThrow();
  ec(fn).toThrow(Error);
  
  // string / regexp
  ec(fn).toThrow('you are using the wrong JDK');
  ec(fn).toThrow(/JDK/);

  ec(Promise.reject(new Error('octopus')))
    .rejects.toThrow('octopus',);
```

### Negation
```js
  ec(true).not.toBeNull();
```

## Mock
Mock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output

### mockImplementation
```js
  const fn = jest.fn().mockImplementation(()=>{})
  // shorthand
  const fn = jest.fn(()=>{})
```

### mock.calls
```js
  const callTimesIndex = 0;
  const callArgsIndex = 0
  mockFn.mock.calls[callTimes][callArgs]
  // ex: 
  const fn = jest.fn(()=>{}) 
  fn(1)
  fn.mock.calls[0][0] === 1
```

### mockImplementationOnce
```js
  const myMockFn = jest
    .fn()
    .mockImplementationOnce(cb => cb(null, true))
    .mockImplementationOnce(cb => cb(null, false));
  myMockFn((err, val) => console.log(val)); // true
  myMockFn((err, val) => console.log(val)); // false

  const myMockFn = jest
    .fn(() => 'default')
    .mockImplementationOnce(() => 'first call')
    .mockImplementationOnce(() => 'second call');
  // 'first call', 'second call', 'default', 'default'
  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### mockReturnValue
```js
  const myMockFn = jest.fn()
    .mockReturnValue('default')
    .mockReturnValueOnce('first call')
    .mockReturnValueOnce('second call');
  // 'first call', 'second call', 'default', 'default'
  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
```

### mockName
```js
  const mockFn = jest.fn().mockName('mockedFunction');
  ec(mockFn).toHaveBeenCalled();
  // result
  // Expected mock function "mockedFunction" to have been called, but it was not called.
```

### mockResolvedValue
```js
    const asyncMock = jest
      .fn()
      .mockResolvedValue('default')
      .mockResolvedValueOnce('first call')
      .mockResolvedValueOnce('second call');

    await asyncMock(); // first call
    await asyncMock(); // second call
    await asyncMock(); // default
    await asyncMock(); // default
```

### mockRejectedValue 
```js
  const asyncMock = jest
    .fn()
    .mockResolvedValueOnce('first call')
    .mockRejectedValueOnce(new Error('Async error'));

  await asyncMock(); // first call
  await asyncMock(); // throws "Async error"
```

### MockedFunction
<note>
jest.MockedFunction is available in the @types/jest module from version 24.9.0
<br/>---------------------------------<br/>
You can use jest.MockedFunction to represent a function that has been replaced by a Jest mock.
</note>

```typescript
  // Assume `add` is imported and used within `calculate`.
  import add from './add';
  import calculate from './calc';
  jest.mock('./add');
  // Our mock of `add` is now fully typed
  const mockAdd = add as jest.MockedFunction<typeof add>;
  calculate('Add', 1, 2);
  expect(mockAdd).toBeCalledTimes(1);
  expect(mockAdd).toBeCalledWith(1, 2);

  // or using jest.fn
  const mockAdd = jest.fn() as jest.MockedFunction<typeof add>;
  mockAdd.mockImplementation((a, b) => a + b);
  calculate(mockAdd, 1, 2);
  expect(mockAdd).toBeCalledTimes(1);
  expect(mockAdd).toBeCalledWith(1, 2);
```

### Module
```js
  // SomeClass.js
  module.exports = class SomeClass {
    m(a, b) {}
  };
  //---------------------------------
  // ModuleTest.js
  jest.mock('./SomeClass'); // this happens automatically with automocking
  const SomeClass = require('./SomeClass');
  const mMock = jest.fn();
  SomeClass.mockImplementation(() => ({ m: mMock }));
  const some = new SomeClass();
  some.m('a', 'b');
  console.log('Calls to m: ', mMock.mock.calls);
```

###  MockedClass
<note>
  jest.MockedClass is available in the @types/jest module from version 24.9.0
</note>

```typescript
  import SoundPlayer from '../sound-player';
  import SoundPlayerConsumer from '../sound-player-consumer';
  jest.mock('../sound-player'); // SoundPlayer is now a mock constructor

  const SoundPlayerMock = SoundPlayer as jest.MockedClass<typeof SoundPlayer>;

  beforeEach(() => {
    // Clear all instances and calls to constructor and all methods:
    SoundPlayerMock.mockClear();
  });

  const soundPlayerConsumer = new SoundPlayerConsumer();
  expect(SoundPlayerMock).toHaveBeenCalledTimes(1);

  const coolSoundFileName = 'song.mp3';
  soundPlayerConsumer.playSomethingCool();

  // mock.instances is available with automatic mocks:
  const mockSoundPlayerInstance = SoundPlayerMock.mock.instances[0];

  // However, it will not allow access to `.mock` in TypeScript as it
  // is returning `SoundPlayer`. Instead, you can check the calls to a
  // method like this fully typed:
  expect(SoundPlayerMock.prototype.playSoundFile.mock.calls[0][0])
    .toEqual(coolSoundFileName);
```

